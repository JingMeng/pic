

1.
stop 废弃

妨碍---文件下载，删除
避免中间状态停止，破坏性比较大

2.

替代的api

标记----------- 和android的invilidate很像  

安全方式

收尾判断的地方可能有很多

多个收尾操作改变
继续中断

3.

那个异常都是主动调用的



4. 45分钟的时候讲错了
锁错了，不可能导致另外的线程一直无法进入
这个要做一个demo验证一下


读也枷锁了，可能会出现这个问题了吗？？？

一定测试


5.

wait会让锁等待
sleep是非让锁等待


6.



锁是会传递，前提是你别离开那个锁的代码块


你离开了，别人就可以抢夺了
再次抢夺就不一定是你了，可能就不会传递了








7.
wait的时候，你没有拿到锁，不会抛出异常，紧急是被唤醒了
59 分钟
等待测试

wait被唤醒并不是直接执行，而是去尝试获取锁
获取到了就执行，没有获取到就继续等待


8.

join
调用的线程希望被调用的线程执行完毕之后自己再执行

yield 静态的---------- 线程优先级
时间片暂时分给同优先级的

9.



在某个指定的运行中的线程执行代码


如果仅仅是换线程new Thread或者线程池都可以


hanlderThread
你要会默写


代码优化的过程



并不是拿到主线程中执行
而是往主线程中塞进去了，主线程在下一次循环到就会取出来了









