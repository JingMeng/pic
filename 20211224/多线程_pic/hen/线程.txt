

1.
stop 废弃

妨碍---文件下载，删除
避免中间状态停止，破坏性比较大

2.

替代的api

标记----------- 和android的invilidate很像  

安全方式

收尾判断的地方可能有很多

多个收尾操作改变
继续中断

3.

那个异常都是主动调用的



4. 45分钟的时候讲错了
锁错了，不可能导致另外的线程一直无法进入
这个要做一个demo验证一下


读也枷锁了，可能会出现这个问题了吗？？？

一定测试


5.

wait会让锁等待
sleep是非让锁等待


6.



锁是会传递，前提是你别离开那个锁的代码块


你离开了，别人就可以抢夺了
再次抢夺就不一定是你了，可能就不会传递了








7.
wait的时候，你没有拿到锁，不会抛出异常，紧急是被唤醒了
59 分钟
等待测试

wait被唤醒并不是直接执行，而是去尝试获取锁
获取到了就执行，没有获取到就继续等待


8.

join
调用的线程希望被调用的线程执行完毕之后自己再执行

yield 静态的---------- 线程优先级
时间片暂时分给同优先级的

9.



在某个指定的运行中的线程执行代码


如果仅仅是换线程new Thread或者线程池都可以


hanlderThread
你要会默写


代码优化的过程



并不是拿到主线程中执行
而是往主线程中塞进去了，主线程在下一次循环到就会取出来了




==============
2.3的loope源码应该是直接wait实现的，不是底层的操作

 所以说也不需要那个解密老师的操作
 直接和线程关联就满足了


这个版本是用了wait
 http://androidxref.com/2.3.6/xref/frameworks/base/core/java/android/os/Looper.java

 enqueueMessage 的时候notify
 next的时候wait，就可以解决高占用的问题的


Linux IO模式及 select、poll、epoll详解
https://segmentfault.com/a/1190000003063859




=========================================
子线程里面可以创建looper吗？

主要是替换那个默认的Looper





使用静态方法获取成员变量
ThreadLocal

 


解释一下hanlder的内存泄漏


在指定的运行中的线程执行代码
指定的没有运行----后台----线程池？？？

asynctask内存泄漏---------
--------------- 内部类持有外部类的引用很好证明，内部类可以调用外部类的
非静态方法或者属性

----------------------------


GC root

看GC Root 是因为我们不希望一个有用的东西被回收
 3种
1. 运行中的线程--------AsyncTask

AsyncTask 被里面的Thread持有
AsyncTask 持有Activity 
处理不好，进而导致内存泄漏------ Activity无法释放--eg：创建了一个普通的对象

2. 静态对象
3. native代码引用

不是因为AsyncTask ，不是因为内部类，是因为GC root
所有的内部类都会导致内存泄漏吗？？？？ 如果是因为内部类的话
----------------------------------
AsyncTask 适合小任务
线程池 能用就用---没有啥缺点，不考虑在拉回来
hanlder 能够交互
handlerThread  -----------类似于主线程------很少使用
handlerThread和线程池 的取消不一样

hanlder和AsyncTask 前台切后台，在从后台切刀前台
不切换，使用线程池



长任务和短任务
简单任务还是复制任务

上面的分别使用什么线程比较好

services和intentServices

intentServices 是自动关闭的
如果需要context考虑他否则使用线程池

services 是后台任务的活动空间



-------------------
这部分讲解主要侧重于线程，真的去实现一个
那部分讲解主要说的主要看点，比如CPu的功耗，已有的实现
















